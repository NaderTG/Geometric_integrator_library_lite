/*
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (C) 2017 Nader Ganaba
 * Created by Nader on 19/12/2017.
 * visualise.h
 */

#ifndef visualise_h
#define visualise_h

#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include "field_traits.h"


template<class FieldClass,
class Traits = field_traits< FieldClass >
>

//Abstract class for visualisation, the idea is to let the user pick the export file format during runtime.
class visFile{
public:
    typedef Traits TraitsType;
    typedef typename TraitsType::StateType    StateType;
    typedef typename TraitsType::Iterator      Iterator;
    
    visFile(std::string _filename):filename(_filename){}
    std::string getName(){ return filename;}
    
    virtual void printName() = 0;
    
protected:
    std::string filename;
    std::ofstream fout;
};

template<class FieldClass,
class Traits = field_traits< FieldClass >
>
//Class for PGM file format
class pgmFile : public visFile<FieldClass>{
public:
    typedef Traits TraitsType;
    typedef typename TraitsType::StateType    StateType;
    typedef typename TraitsType::Iterator      Iterator;
    
    pgmFile(std::string _filename) : visFile<FieldClass>(_filename + ".pgm") {
        
    }
    void printName(){
        std::cout << this->filename << std::endl;
    }
    
    void saveData(FieldClass& _field){
        this->fout.open(this->filename.c_str());
        if (!this->fout.is_open())
        {
            std::cout << "Can't open output file"  << this->filename << std::endl;
            exit(1);
        }
        
        //Writing the header
        
        int nx2 =(_field.getNx()+2);
        int ny2 =(_field.getNy()+2);
        this->fout << "P2\n" << nx2<< " " << ny2 << "\n255\n";
        
        //Writing the data
        
        Iterator it_v;
        for(int i = 0; i < nx2; i++){
            for(int j = 0 ; j < ny2-1; j++){
                it_v = _field.getV(i,j);
                this->fout <<    (*it_v) << " ";
            }
            it_v = _field.getV(i,ny2-1);
            this->fout <<   (*it_v)   << "\n";
            
        }
        
        
        // closing the stream
        this->fout.close();
        
    }
};

template<class FieldClass,
class Traits = field_traits< FieldClass >
>
//Class for VTK file format
class vtkOutFile : public visFile<FieldClass>{
public:
    typedef Traits TraitsType;
    typedef typename TraitsType::StateType    StateType;
    typedef typename TraitsType::Iterator      Iterator;
    
    vtkOutFile(std::string _filename) : visFile<FieldClass>(_filename + ".vtk") {
        
    }
    void printName(){
        std::cout << this->filename << std::endl;
    }
    
    void saveData(FieldClass& _field){
        this->fout.open(this->filename.c_str());
        if (!this->fout.is_open())
        {
            std::cout << "Can't open output file"  << this->filename << std::endl;
            exit(1);
        }
        
        //Writing the header
        
        int nx2 =(_field.getNx()+2);
        int ny2 =(_field.getNy()+2);
        
        double dx =_field.getDx();
        double dy =_field.getDy();
        Iterator it_v, it_w;
        this->fout << "P2\n" << nx2<< " " << ny2 << "\n255\n";
        
        this->fout << "# vtk DataFile Version 2.0"<< std::endl;
        this->fout << "generated by GNIL Library output class"<< std::endl;
        this->fout << "ASCII"<< std::endl<< std::endl;
        this->fout << "DATASET STRUCTURED_GRID"<< std::endl;
        this->fout << "DIMENSIONS " << nx2 << " " << ny2 << " 1 " << std::endl;
        this->fout << "POINTS " << (nx2*ny2) << " float" << std::endl << std::endl;
        
        
        //Writing coordinate points
        for(int j = 0; j < ny2; j++) {
            for(int i = 0; i < nx2; i++) {
                this->fout << (i*dx) << " " << (j*dy) << " 0" << std::endl;
            }
        }
        
        //Writing the stream function
        this->fout << "CELL_DATA " << (nx2*ny2) << " \n";
        this->fout <<  "SCALARS stream float 1 \n";
        this->fout <<  "LOOKUP_TABLE default \n";
        
        
        for(int j = 1 ; j < ny2-1; j++){
            for(int i = 1; i < nx2-1; i++){
                
                it_v = _field.getV(i,j);
                this->fout << (*it_v) << std::endl;
                
            }
            
            //Writing the vorticity function
            this->fout << "\nCELL_DATA " << (nx2*ny2) << " \n";
            this->fout <<  "SCALARS stream float 1 \n";
            this->fout <<  "LOOKUP_TABLE default \n";
            
            Iterator it_v;
            for(int j = 1 ; j < ny2-1; j++){
                for(int i = 1; i < nx2-1; i++){
                    
                    it_w = _field.getW(i,j);
                    this->fout << (*it_w) << std::endl;
                    
                }
            }
            // closing the stream
            this->fout.close();
            
        }
    }
};

#endif /* visualise_h */
